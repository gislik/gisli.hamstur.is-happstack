{-# LANGUAGE TemplateHaskell, DeriveDataTypeable, TypeFamilies, 
             FlexibleContexts, FlexibleInstances,
             MultiParamTypeClasses, TypeSynonymInstances #-}
module AppState where

import HAppS.Server
import HAppS.State
import Data.Generics
import Control.Monad.Reader
import Control.Monad.State
import Data.Map
import qualified Data.Map as M
import Data.Digest.OpenSSL.MD5 (md5sum)
import Data.ByteString.Char8 (pack)
import Data.ByteString.Lazy.Char8 (unpack)
import GHC.Conc
import Model.Blog
import Model.User
import AppState.Session
import Util

import Text.StringTemplate

data AppState = AppState {
     blogs         :: Blogs,
     users         :: Users,
     sessions      :: Session SessionData
} deriving (Show, Read, Typeable, Data)                                         

instance Version AppState
$(deriveSerialize ''AppState) 

instance Component AppState where 
         type Dependencies AppState = End 
         initialValue = AppState { 
                      blogs =  [
                                   Blog {blogID=0, blogTitle="Test 1", blogBody="asdf asdfasdf asdf asd", 
--blogDate=time, 
                                        blogAuthor="GK"}, 
                                   Blog {blogID=0, blogTitle="Test 2", blogBody="blah blah blah", 
--blogDate=time, 
                                         blogAuthor="GK"}
                 ],
                        users = singleton username user,
                        sessions = Session { session=empty }
                        }
                        where user :: User
                              user = User username password name
                              username = "gislik"
                              password = "birkvisl"
                              name = "Gisli Kristjansson"

-- BLOGS
addSerialToBlogs :: [Blog] -> [Blog]
addSerialToBlogs = addSerialToBlogs' 1

addSerialToBlogs' :: Int -> [Blog] -> [Blog]
addSerialToBlogs' _ [] = []
addSerialToBlogs' n (blog:blogs) = blog {blogID=n} : addSerialToBlogs' (n+1) blogs

listBlogs :: MonadReader AppState m => m [Blog]
listBlogs = return . addSerialToBlogs . blogs =<< ask

askUsers :: (MonadReader AppState m) => m Users
askUsers = return . users =<< ask
 

-- USERS
listUsers :: (MonadReader AppState m) => m [String]
listUsers = liftM keys askUsers

authUser :: (MonadReader AppState m) => String -> String -> m (Maybe User)
authUser name pass = do
         user <- liftM (M.lookup name) askUsers
         case user of
              Just user' -> do
                   if password user' == pass
                      then return user
                      else return Nothing
              Nothing -> return Nothing
                           
-- SESSIONS



renderLayout :: (Stringable a) =>
                AppEnv a String -> 
                Maybe (StringTemplate a -> StringTemplate a) -> 
                IO Response
renderLayout env attrs = do
             layoutTemplate 	<- parseLayout env
             renderResponse $ maybe id id attrs layoutTemplate

