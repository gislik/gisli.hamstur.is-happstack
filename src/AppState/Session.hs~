{-# LANGUAGE TemplateHaskell, FlexibleContexts, FlexibleInstances,
             DeriveDataTypeable, MultiParamTypeClasses, TypeSynonymInstances #-}

{- 
  TypeFamilies, 
             FlexibleContexts,
             MultiParamTypeClasses, TypeSynonymInstances 
-}
module Session where

import AppState.Model
import Model.User
import Data.Generics
--import Control.Monad.State
import HAppS.Server
import HAppS.State
import Control.Monad.Reader
import Control.Monad.State
import Data.Digest.OpenSSL.MD5 (md5sum)
import qualified Data.Map as M
import GHC.Conc
import Data.ByteString.Char8 (pack)
import Util

askSession :: (MonadReader AppState m) => m (Session SessionData)
askSession = return . sessions =<< ask

modSession :: (MonadState AppState m) => (Session SessionData -> Session SessionData) -> m ()
modSession f = modify $ \state@(AppState {sessions=s}) -> state {sessions=f s}

isSession :: (MonadReader AppState m) => SessionID -> m Bool
isSession sid = liftM (M.member sid . session) askSession

getSession :: (MonadReader AppState m) => SessionID -> m (Maybe SessionData)
getSession sid = liftM (M.lookup sid . session) askSession

setSession :: (MonadState AppState m) => SessionID -> SessionData -> m ()
setSession sid sdata = modSession $ Session . M.insert sid sdata . session 

newSession :: (MonadState
                 AppState (Ev (t STM)),
               Monad (t STM),
               MonadTrans t) =>
              SessionData -> Ev (t STM) SessionID
newSession sdata = do
           sid <- getRandom
           let ssid = ((md5sum.pack.show) (sid::Integer))::SessionID
           setSession ssid sdata
           return ssid

listSessions :: (MonadReader AppState m) => m [SessionID]
listSessions = liftM (M.keys . session) askSession

delSession :: (MonadState AppState m) => SessionID -> m ()
delSession sid = modSession $ Session . (M.delete sid) . session


