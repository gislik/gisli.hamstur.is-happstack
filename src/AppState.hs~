{-# LANGUAGE TemplateHaskell, DeriveDataTypeable, TypeFamilies, 
             FlexibleContexts, FlexibleInstances,
             MultiParamTypeClasses, TypeSynonymInstances #-}
module AppState where

import HAppS.Server
import HAppS.State
import Control.Monad.State
import Data.Map
import Data.Maybe
import Model.Blog
import Model.User
import Util
import AppState.Model
import AppState.Session
import AppState.Blog
import AppState.User


instance Component AppState where 
         type Dependencies AppState = End 
         initialValue = AppState { 
                      blogs =  [],
                      users = singleton username user,
                      sessions = Session { session=empty }
                      }
                      where user :: User
                            user = User username password name
                            username = "gislik"
                            password = Just "e47bb6e298348b2fa1aaa5e7c8c40cb1"
                            name = "G&iacute;sli Kristj&aacute;nsson"


$(mkMethods ''AppState ['listBlogs, 'modBlogs, 'authUser, 'getUser, 'getSession, 'isSession, 'setSession, 'newSession, 'delSession, 'listSessions])


withSession :: (Maybe SessionData -> WebT IO a) 
                      -> ServerPartT IO a
withSession sessionController = withCookie "sid" $ \sid -> do
            session <- query $ GetSession sid
            sessionController session

-- TODO:
-- only wrap if has content (200)
-- Copy original response object
wrapLayout :: ServerPartT IO LayoutResponse -> ServerPartT IO Response
wrapLayout sp = do
           withRequest $ \req -> do
                       (LayoutResponse attrs)    <- unServerPartT sp $ req
                       env    <- liftIO appEnv :: (WebT IO) (AppEnv String String)                        
                       sdata  <- query $ GetSession $ sid req
--                       let u = maybe NoUser user sdata
                       case sdata of 
                            Just u  -> do
                                 let attrUser = attr "user" (user u)
                                 layoutTemplate <- liftM attrUser (parseLayout env)
                                 let l = maybe id id attrs layoutTemplate
                                 liftIO $ renderResponse l
                            Nothing -> do 
                                    layoutTemplate <- parseLayout env
                                    let l = maybe id id attrs layoutTemplate
                                    liftIO $ renderResponse l
            where sid req = maybe "" id $ readData ((readCookieValue "sid")::RqData SessionID) req




wrapUserLayout :: ServerPartT IO (LayoutResponse' User) -> ServerPartT IO Response
wrapUserLayout sp = do
           withRequest $ \req -> do
                       (LayoutResponse' attrs)    <- unServerPartT sp $ req
                       env    <- liftIO appEnv :: (WebT IO) (AppEnv String String)                        
                       sdata  <- query $ GetSession $ sid req
                       case sdata of 
                            Just d  -> do
                                 let u = user d
                                 let attrUser = attr "user" u
                                 layoutTemplate <- liftM attrUser (parseLayout env)
                                 let l = maybe id (\f -> f u) attrs layoutTemplate
                                 liftIO $ renderResponse l
                            Nothing -> do 
                                    layoutTemplate <- parseLayout env
                                    let l = maybe id (\f -> f NoUser) attrs layoutTemplate
                                    liftIO $ renderResponse l
            where sid req = maybe "" id $ readData ((readCookieValue "sid")::RqData SessionID) req







wrapFilter :: [ServerPartT IO LayoutResponse] -> [ServerPartT IO Response]
wrapFilter = Prelude.map wrapLayout

withAuthentication :: ServerPartT IO Response -> ServerPartT IO Response
withAuthentication sp = do
                   withRequest $ \req -> do
                               unServerPartT (withSession (sess req)) req
                   where sess req (Just sdata) = do
                              uid <- query $ GetUser ((username.user) sdata)
                              maybe unauthResponse (const (unServerPartT sp req)) uid
                         sess _ Nothing = unauthResponse
                         unauthResponse = unauthorized.toResponse $ "unauthorized"
